BEGIN{
    false = 0;      true = 1

    RS="\034"

    enable_comment_parsing = false
    enable_pseudo_string = true

    # if.def op
    # op="extract";     op_pattern=""
    # op="replace";     op_pattern="";  op_value=""
    # op="length";      op_pattern=""
    # op="prepend";     op_pattern="";  op_value=""
    # op="push";        op_pattern="";  op_value=""
    # op="pop";         op_pattern=""
    # op=false;   op_pattern=""
    # end.def omp

    out_compact = false;
    out_color = true
    out_format = true;  # Using compilation switch to enable or disable code
    out_indent_step = 2
    out_indent_space = "  "

    if (out_color_key == 0)     out_color_key = "\033[0;35m"
    if (out_color_string == 0)  out_color_string = "\033[0;34m"
    if (out_color_number == 0)  out_color_number = "\033[0;32m"
    if (out_color_null == 0)    out_color_null = "\033[0;33m"   # "\033[0;31m"
    if (out_color_true == 0)    out_color_true = "\033[7;32m"
    if (out_color_false == 0)   out_color_false = "\033[7;31m"

    inner_content_generate = true  # For extract

    # TODO: Advance
    # 1. Using \n to seperate .[].1.abc, check all of the space
    # 2. Extract the data? Then? Output the result? OK. Using a variable to control string operation.
    # 3. 

    query_string = ""
    replace_string = "query => value"
}

function query(s,   arr, tmp, e, idx, n, item){
    s1 = s
    e = "\034"

    gsub(/\\\\/, "\001\001", s)
    gsub(/\\"/, "\002\002", s)  # "
    gsub(/\\\./, "\003\003", s)

    # gsub(/\./, "\034", s)
    # gsub(/\./, "|", s) # for debug

    n = split(s, arr, ".")
    if (arr[1] == "") tmp = 0
    for (idx=2; idx<=n; idx ++) {
        item = arr[idx]
        if ( (match( item, /(^\[)|(^\")|(^\*$)|(^\*\*$)/ ) == false) ) {   #"
            tmp = tmp "\034" "\"" item "\""
        } else {
            tmp = tmp "\034" item
        }
    }
    s = tmp

    gsub("\003\003", ".", s)
    gsub("\002\002", "\\\"", s)  # "
    gsub("\001\001", "\\\\", s)

    # gsub(/\*/, "[^|]+", s)   # for debug
    # gsub(/\*\*/, "([^|]+|)*[^|]+", s)    # for debug

    gsub(/\*/, "[^\034]+", s)
    gsub(/\*\*/, "([^\034]+\034)*[^\034]+", s)

    gsub(/"[^"]+"/, "([^\034]+\034)*[^\034]+", s)   #"

    return s
}

function debug(msg){
	print "idx[" s_idx "]  DEBUG:" msg > "/dev/stderr"
}

function json_walk_panic(msg,       start){
    start = s_idx - 10
    if (start <= 0) start = 1
    print ("value " _ord_[substr(s, s_idx, 1)]) > "/dev/stderr"
    print (msg " [index=" s_idx "]:\n-------------------\n" substr(text, start, s_idx - start)  "|"  substr(text, s_idx, 1) "|" substr(text, s_idx+1, 30) "\n-------------------") > "/dev/stderr"
    exit 1
}

function json_walk_pseudo_string(     ss, pos){
    # debug("json_walk_string start() ")

    ss = substr(s, s_idx, 64)
    match(ss, /(^"[^"]*"?)|(^[^\n\ #\/\[{}\],:]+)/)
    # match(ss, /(^"[^"]*"?)|(^[A-Za-z0-9_-\/$]+)/)
    if (RLENGTH <= 0) return false

    if (RLENGTH != 64) {
        result = substr(text, s_idx, RLENGTH)
        s_idx += RLENGTH
        if (match(result, /^"/) == false) {
            result = "\"" result "\""
        }
        return true
    }

    # match(substr(s, s_idx), /(^"[^"]*")|(^[A-Za-z0-9_-\/$]+)/);   
    match(substr(s, s_idx), /(^"[^"]*"?)|(^[^\n\ #\/\[{}\],:]+)/)   # "
    pos = RLENGTH  # index() is no way better then match()
    if (pos <= 0) json_walk_panic("json_walk_string() Expect \"")

    # if.def stringify
    if (inner_content_generate) result = substr(text, s_idx, pos)
    # end.if

    s_idx += pos
    return true
}

# If found not starts with ", go to another pattern.
# Check true, false, null, number, then try string.

function json_walk_strict_string(     pos){
# function json_walk_string(     pos){
    # debug("json_walk_string start() ")

    match(substr(s, s_idx, 64), /^("[^"]*"?)/)
    if (RLENGTH <= 0) return false
    # if (substr(s, s_idx + RLENGTH - 1, 1) == "\"") { # Performance defect design
    if (RLENGTH != 64) {
        # if.def stringify
        if (inner_content_generate)  result = substr(text, s_idx, RLENGTH)
        s_idx += RLENGTH
        # end.if
        return true
    }

    # if (substr(s, s_idx, 1) != "\"") {
    #     # debug("json_walk_string not right() ")
    #     return false
    # }

    s_idx ++
    # match(substr(s, s_idx), /[^"]+"/);    pos = RLENGTH  # index() is no way better then match()
    pos = index(substr(s, s_idx), "\"")
    if (pos <= 0) json_walk_panic("json_walk_string() Expect \"")

    # if.def stringify
    if (inner_content_generate) result = substr(text, s_idx-1, pos+1)
    # end.if

    s_idx += pos
    return true
}

function json_walk_string(){
    if (enable_pseudo_string == true) {
        return json_walk_pseudo_string()
    }
    return json_walk_strict_string()
}

function json_walk_empty(   sw, o_idx, oo_idx){
    if (enable_comment_parsing == false) {
        o_idx = s_idx
        sw = json_walk_empty0()
        if (out_compact == true) {
            result = ""
        } else {
            result = substr(text, o_idx, s_idx - o_idx)
        }
        return sw
    }

    sw = false
    oo_idx = s_idx
    while (1) {
        o_idx = s_idx
        json_walk_empty0()
        json_walk_comment()
        if (o_idx == s_idx) break
        sw = true
    }

    if (sw == true) {
        if (out_compact == true) {
            result = ""
        } else {
            result = substr(text, oo_idx, s_idx - oo_idx)
        }
    }
    return sw
}

function json_walk_comment(     ss, pos){
    ss = substr(s, s_idx, 2)
    # debug("json_walk_comment() starts ->" ss)

    # TODO: Using preload tecknique to accelerate
    if (( ss == "//") || (substr(s, s_idx, 1) == "#") ) {
        pos = index(substr(s, s_idx), "\n")
        if (pos <= 0) {
            s_idx = s_len + 1
        } else {
            s_idx += pos
        }
        
        return true
    }

    if ( ss == "/*" ) {
        pos = index(substr(s, s_idx), "*/")
        if (pos <= 0) json_walk_panic("json_walk_comment() Expect */")
        s_idx += pos + 1    # Notice "*/"
        return true
    }
    return false
}

function json_walk_empty0(   o_idx){
    # if (substr(s, s_idx, 1) != " ") return false
    match(substr(s, s_idx, 16), /^[ \n]+/)
    if (RLENGTH <= 0) return false
    o_idx = s_idx
    if (RLENGTH == 16) {   
        s_idx += 16
        match(substr(s, s_idx), /^[ \n]+/)
    }
    if (RLENGTH > 0) s_idx += RLENGTH
    return true
}

function json_walk_dict(    ret, nth, cur_indent, bak_indent, inner_content_generate_bak ){
    if (substr(s, s_idx, 1) != "{") {
        # debug("json_walk_dict() fails" )
        return false
    }
    
    JSON_WALK_KP_IDX ++;    nth = -1
    if (inner_content_generate) ret = ret "{"
    s_idx ++;

    bak_indent = JSON_INDENT
    JSON_INDENT = JSON_INDENT out_indent_space
    cur_indent = JSON_INDENT
    
    while (1) {
        nth ++
        if (json_walk_empty() == true) {     # optional
            ret = ret result
        }

        if (substr(s, s_idx, 1) == "}") {
            JSON_WALK_KP_IDX --
            if (inner_content_generate) {
                if (out_format == true) {
                    if (nth == 0) {
                        ret = ret "}"
                    } else {
                        ret = ret "\n" bak_indent "}"
                    }
                } else {
                    ret = ret "}"
                }
            }
            s_idx ++;  break
        } else {
            inner_content_generate_bak = inner_content_generate
            inner_content_generate = true
            if (json_walk_string() == false) {    # key
                json_walk_panic("json_walk_dict() Expect a key")
            }
            JSON_WALK_KP[JSON_WALK_KP_IDX] = result
            inner_content_generate = inner_content_generate_bak

            if (inner_content_generate) {
                # if.def color
                if (out_color == true) result = out_color_key result "\033[0m"
                # end.if[]

                if (out_format == true) {
                    ret = ret "\n" cur_indent result
                } else {
                    ret = ret result
                }
            }
        }

        if (json_walk_empty() == true) {     # optional
            ret = ret result
        }

        if (substr(s, s_idx, 1) == ":") {
            if (inner_content_generate) {
                if (out_format == true) {
                    ret = ret ": "
                } else {
                    ret = ret ":"
                }
            }
            s_idx ++;
        } else {
            json_walk_panic("json_walk_dict() Expect :")
        }

        if (json_walk_empty() == true) {     # optional
            ret = ret result
        }

        if (json_walk_value() == false) {     # value
            json_walk_panic("json_walk_dict() Expect a value")
        }

        ret = ret result

        if (json_walk_empty() == true) {     # optional
            ret = ret result
        }

        if (substr(s, s_idx, 1) == ",") {
            ret = ret ","
            s_idx ++;
        }
    }

    # debug("json_walk_dict: " JSON_WALK_DICT_TOKEN)
    result = ret

    JSON_INDENT = bak_indent
    return true
}

function json_walk_array(       ret, nth, cur_indent, bak_indent){
    # debug("json_walk_array start() ")
    if (substr(s, s_idx, 1) != "[") return false

    JSON_WALK_KP_IDX ++;    nth = -1
    if (inner_content_generate) ret = "["
    s_idx ++

    bak_indent = JSON_INDENT
    JSON_INDENT = JSON_INDENT out_indent_space
    cur_indent = JSON_INDENT
    
    while (1) {
        nth++;
        
        # debug("loop")
        if (json_walk_empty() == true) {   # optional
            ret = ret result
        }

        if (substr(s, s_idx, 1) == "]") {
            JSON_WALK_KP_IDX --
            if (inner_content_generate) {
                if (out_format == true) {
                    if (nth == 0) {
                        ret = ret "]"
                    } else {
                        ret = ret "\n" bak_indent "]"
                    }
                } else {
                    ret = ret "]"
                }
            }
            s_idx ++;   break
        } else {
            JSON_WALK_KP[JSON_WALK_KP_IDX] = nth

            if (json_walk_value() == false)  json_walk_panic("json_walk_array() Expect a value")
            
            if (inner_content_generate) {
                if (out_format == true) {   # value
                    ret = ret "\n" cur_indent result
                } else {
                    ret = ret result
                }
            }
        }


        if (json_walk_empty() == true) {     # optional
            if (inner_content_generate) ret = ret result
        }

        if (substr(s, s_idx, 1) == ",") {
            if (inner_content_generate) ret = ret ","
            s_idx ++;
        }
    }
    # debug("json_walk_array end(): " JSON_WALK_ARRAY_TOKEN)
    result = ret

    JSON_INDENT = bak_indent
    return true
}

function json_walk_number(      o_idx) {
    # if (substr(s, s_idx, 1) != "0") return false
    match(substr(s, s_idx, 8), /^0+/)
    if (RLENGTH <= 0) return false
    o_idx = s_idx
    if (RLENGTH == 8) {
        s_idx += 8
        match(substr(s, s_idx), /^0+/)
    }
    if (RLENGTH > 0)   s_idx += RLENGTH
    # if.def color
    if (inner_content_generate) {
        if (out_color == true)  result = out_color_number substr(text, o_idx, s_idx - o_idx) "\033[0m"
        else                    result = substr(text, o_idx, s_idx - o_idx)
    }
    # end.if
    # debug("json_walk_number() return true " RLENGTH)
    return true
}

function json_walk_primitive(     tmps){
    if (json_walk_number() == true) return true

    # true => tru0, false => fals0
    tmps = substr(s, s_idx, 4)
    if (tmps == "tru0") {
        s_idx += 4
        if (inner_content_generate) {
            # if.def color
            if (out_color == true)  result = out_color_true "true" "\033[0m"
            else                    result = "true"
            # end.if
        }
        return true
    } 
    
    if (tmps == "null") {
        s_idx += 4
        if (inner_content_generate) {
            # if.def color
            if (out_color == true)  result = out_color_null "null" "\033[0m"
            else                    result = "null"
            # end.if
        }
        return true
    } 
    
    if ( substr(s, s_idx, 5) == "fals0" ) {
        s_idx += 5;
        if (inner_content_generate) {
            # if.def color
            if (out_color == true)  result = out_color_false "false" "\033[0m"
            else                    result = "false"
            # end.if
        }
        return true
    }
    return false
}

# string | primitive | dict | array
function json_walk_value(     ){

    # Must before the json_walk_string in case of pseudostring enable
    if (json_walk_primitive() == true) return true

    if (json_walk_string() == true) {    # key
        if (inner_content_generate) {
            # if.def color
            if (out_color == true) result = out_color_string result "\033[0m"
            # end.if
        }
        return true
    }

    if (json_walk_dict() == true) return true
    if (json_walk_array() == true) return true
    
    json_walk_panic("json_walk_value() Expect a value")
    return false
}

function json_walk_cb(s, idx0, idx1){
    print("---", idx1 substr(s, idx0, idx1 - idx0))
}

function _json_walk(    final, idx, nth){

    nth = -1
    while (s_idx <= s_len) {

        idx = s_idx
        
        if (json_walk_empty() == true) {     # optional
            # Do some thing in stringify()
        }

        nth ++;     JSON_WALK_KP_IDX = 1
        JSON_WALK_KP[1] = nth

        if (json_walk_value() == false) {
            # debug("json_walk_value() Out -> " s_idx " : " )
            # break
            return
        }

        final = final "\n" result
        # consume value: Do some thing in stringify()

        if (json_walk_empty() == true) {     # optional
            # Do some thing in stringify()
        }

        if (s_idx == idx) {
            json_walk_panic("json_walk() Expect a value")
        }
        
            # json_walk_cb(s, idx, s_idx)
    }

    return final
}

# global variable: text, s, s_idx, s_len
function json_walk(text_to_parsed,   b_s, b_result, b_s_idx, b_s_len, b_text, final){
    b_result = result;  b_text = text;
    b_s = s;    b_s_idx = s_idx;    b_s_len = s_len;

    result = "";        text = text_to_parsed;  

    if ( out_format != false ) out_compact = true

    # if (out_compact == true) {
    #     gsub(/^\357\273\277|^\377\376|^\376\377|"[^"\\\000-\037]*((\\[^u\000-\037]|\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])[^"\\\000-\037]*)*"|-?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?|null|false|true|[ \t\n\r]+|./, "\n&", text)
	#     gsub("\n" "[ \t\n\r]+", "\n", text)
    # }

    s = text;   s_idx = 1;          s_len = length(s)
    
    JSON_WALK_KP_IDX = 0
    JSON_INDENT = "";   out_indent_space=sprintf("%" out_indent_step "s", "")

    if (op_pattern) {
        op_pattern = query(op_pattern)
        debug("op_pattern")
    }

    gsub(/\\\\/, "__", s)
    gsub(/\\"/, "__", s)
    gsub(/[0123456789eE\.\+\-]/, 0, s) # number value
    
    gsub(/[\t\b\r\v]/, " ", s)

    final = _json_walk()

    result = b_result;
    text = b_text;  s = b_s;    s_idx = b_s_idx;    s_len = b_s_len;

    return final
}

{
    print json_walk($0)
}
