BEGIN{
    false = 0;      true = 1

    RS="\034"

    enable_comment_parsing = true
    out_compact = false;
    out_color = false
    out_format = false;  # Using compilation switch to enable or disable code
    out_indent_step = 2

    if (out_color_key == 0)     out_color_key = "\033[0;35m"
    if (out_color_string == 0)  out_color_string = "\033[0;34m"
    if (out_color_number == 0)  out_color_number = "\033[0;32m"
    if (out_color_null == 0)    out_color_null = "\033[0;33m"   # "\033[0;31m"
    if (out_color_true == 0)    out_color_true = "\033[7;32m"
    if (out_color_false == 0)   out_color_false = "\033[7;31m"

    # TODO
    # Using \n to seperate .[].1.abc, check all of the space
    # Extract the data? Then? Output the result? OK. Using a variable to controle string operation.
    query_string = ""
    replace_string = "query => value"
}

function debug(msg){
	print "idx[" s_idx "]  DEBUG:" msg > "/dev/stderr"
}

function json_walk_panic(msg,       start){
    start = s_idx - 10
    if (start <= 0) start = 1
    print ("value " _ord_[substr(s, s_idx, 1)]) > "/dev/stderr"
    print (msg " [index=" s_idx "]:\n-------------------\n" substr(text, start, s_idx - start)  "|"  substr(text, s_idx, 1) "|" substr(text, s_idx+1, 30) "\n-------------------") > "/dev/stderr"
    exit 1
}

# If found not starts with ", go to another pattern.
# Check true, false, null, number, then try string.

function json_walk_string(     pos){
    # debug("json_walk_string start() ")

    match(substr(s, s_idx, 64), /^("[^"]*"?)/)
    if (RLENGTH <= 0) return false
    if (substr(s, s_idx + RLENGTH - 1, 1) == "\"") {
        # if.def stringify
        result = substr(text, s_idx, RLENGTH)
        s_idx += RLENGTH
        # end.if
        return true
    }

    # if (substr(s, s_idx, 1) != "\"") {
    #     # debug("json_walk_string not right() ")
    #     return false
    # }

    s_idx ++
    # match(substr(s, s_idx), /[^"]+"/);    pos = RLENGTH  # index() is no way better then match()
    pos = index(substr(s, s_idx), "\"")
    if (pos <= 0) json_walk_panic("json_walk_string() Expect \"")

    # if.def stringify
    result = substr(text, s_idx-1, pos+1)
    # end.if

    s_idx += pos
    return true
}

function json_walk_empty(   sw, o_idx, oo_idx){
    if (enable_comment_parsing == false) {
        o_idx = s_idx
        sw = json_walk_empty0()
        if (out_compact == true) {
            result = ""
        } else {
            result = substr(text, o_idx, s_idx - o_idx)
        }
        return sw
    }

    sw = false
    oo_idx = s_idx
    while (1) {
        o_idx = s_idx
        json_walk_empty0()
        json_walk_comment()
        if (o_idx == s_idx) break
        sw = true
    }

    if (sw == true) {
        if (out_compact == true) {
            result = ""
        } else {
            result = substr(text, oo_idx, s_idx - oo_idx)
        }
    }
    return sw
}

function json_walk_comment(     ss, pos){
    ss = substr(s, s_idx, 2)
    # debug("json_walk_comment() starts ->" ss)

    # TODO: Using preload tecknique to accelerate
    if (( ss == "//") || (substr(s, s_idx, 1) == "#") ) {
        pos = index(substr(s, s_idx), "\n")
        if (pos <= 0) {
            s_idx = s_len + 1
        } else {
            s_idx += pos
        }
        
        return true
    }

    if ( ss == "/*" ) {
        pos = index(substr(s, s_idx), "*/")
        if (pos <= 0) json_walk_panic("json_walk_comment() Expect */")
        s_idx += pos + 1    # Notice "*/"
        return true
    }
    return false
}

function json_walk_empty0(   o_idx){
    # if (substr(s, s_idx, 1) != " ") return false
    match(substr(s, s_idx, 16), /^[ \n]+/)
    if (RLENGTH <= 0) return false
    o_idx = s_idx
    if (RLENGTH == 16) {   
        s_idx += 16
        match(substr(s, s_idx), /^[ \n]+/)
    }
    if (RLENGTH > 0) s_idx += RLENGTH
    return true
}

function json_walk_dict(    ret, nth){
    if (substr(s, s_idx, 1) != "{") {
        # debug("json_walk_dict() fails" )
        return false
    }
    
    JSON_WALK_KP_IDX ++;    nth = -1
    ret = ret "{"
    s_idx ++;
    
    while (1) {
        nth ++
        if (json_walk_empty() == true) {     # optional
            ret = ret result
        }

        if (substr(s, s_idx, 1) == "}") {
            JSON_WALK_KP_IDX --
            if (out_format == true) {
                if (nth == 0) {
                    ret = ret "}"
                } else {
                    ret = ret "\n" (sprintf("%" ( - (JSON_WALK_KP_IDX - 1) * out_indent_step)  "s", "")) "}"
                }
            } else {
                ret = ret "}"
            }
            s_idx ++;  break
        } else {
            if (json_walk_string() == false) {    # key
                json_walk_panic("json_walk_dict() Expect a key")
            }
            JSON_WALK_KP[JSON_WALK_KP_IDX] = result

            # if.def color
            if (out_color == true) result = out_color_key result "\033[0m"
            # end.if[]

            if (out_format == true) {
                ret = ret "\n" (sprintf("%" ( - (JSON_WALK_KP_IDX - 1) * out_indent_step)  "s", "")) result
            } else {
                ret = ret result
            }
        }

        if (json_walk_empty() == true) {     # optional
            ret = ret result
        }

        if (substr(s, s_idx, 1) == ":") {
            if (out_format == true) {
                ret = ret ": "
            } else {
                ret = ret ":"
            }
            s_idx ++;
        } else {
            json_walk_panic("json_walk_dict() Expect :")
        }

        if (json_walk_empty() == true) {     # optional
            ret = ret result
        }

        if (json_walk_value() == false) {     # value
            json_walk_panic("json_walk_dict() Expect a value")
        }

        ret = ret result

        if (json_walk_empty() == true) {     # optional
            ret = ret result
        }

        if (substr(s, s_idx, 1) == ",") {
            ret = ret ","
            s_idx ++;
        }
    }

    # debug("json_walk_dict: " JSON_WALK_DICT_TOKEN)
    result = ret
    return true
}

function json_walk_array(       ret, nth){
    # debug("json_walk_array start() ")
    if (substr(s, s_idx, 1) != "[") return false

    JSON_WALK_KP_IDX ++;    nth = -1
    ret = "["
    s_idx ++
    
    while (1) {
        nth++;
        
        # debug("loop")
        if (json_walk_empty() == true) {   # optional
            ret = ret result
        }

        if (substr(s, s_idx, 1) == "]") {
            JSON_WALK_KP_IDX --
            if (out_format == true) {
                if (nth == 0) {
                    ret = ret "]"
                } else {
                    ret = ret "\n" (sprintf("%" ( - (JSON_WALK_KP_IDX - 1) * out_indent_step)  "s", "")) "]"
                }
            } else {
                ret = ret "]"
            }
            s_idx ++;   break
        } else {
            JSON_WALK_KP[JSON_WALK_KP_IDX] = nth

            if (json_walk_value() == false)  json_walk_panic("json_walk_array() Expect a value")
            if (out_format == true) {   # value
                ret = ret "\n" (sprintf("%" ( - (JSON_WALK_KP_IDX - 1) * out_indent_step)  "s", "")) result
            } else {
                ret = ret result
            }
        }

        if (json_walk_empty() == true) {     # optional
            ret = ret result
        }

        if (substr(s, s_idx, 1) == ",") {
            ret = ret ","
            s_idx ++;
        }
    }
    # debug("json_walk_array end(): " JSON_WALK_ARRAY_TOKEN)
    result = ret
    return true
}

function json_walk_cb_value(token){
    return token
}

function json_walk_number(      o_idx) {
    # if (substr(s, s_idx, 1) != "0") return false
    match(substr(s, s_idx, 8), /^0+/)
    if (RLENGTH <= 0) return false
    o_idx = s_idx
    if (RLENGTH == 8) {
        s_idx += 8
        match(substr(s, s_idx), /^0+/)
    }
    if (RLENGTH > 0)   s_idx += RLENGTH
    # if.def color
    if (out_color == true)  result = out_color_number substr(text, o_idx, s_idx - o_idx) "\033[0m"
    else                    result = substr(text, o_idx, s_idx - o_idx)
    # end.if
    # debug("json_walk_number() return true " RLENGTH)
    return true
}

function json_walk_primitive(     tmps){
    if (json_walk_number() == true) return true

    # true => tru0, false => fals0
    tmps = substr(s, s_idx, 4)
    if (tmps == "tru0") {
        s_idx += 4
        # if.def color
        if (out_color == true)  result = out_color_true "true" "\033[0m"
        else                    result = "true"
        # end.if
        return true
    } 
    
    if (tmps == "null") {
        s_idx += 4
        # if.def color
        if (out_color == true)  result = out_color_null "null" "\033[0m"
        else                    result = "null"
        # end.if
        return true
    } 
    
    if ( substr(s, s_idx, 5) == "fals0" ) {
        s_idx += 5;
        # if.def color
        if (out_color == true)  result = out_color_false "false" "\033[0m"
        else                    result = "false"
        # end.if
        return true
    }
    return false
}

# string | primitive | dict | array
function json_walk_value(     ){

    if (json_walk_string() == true) {    # key
        # if.def color
        if (out_color == true) result = out_color_string result "\033[0m"
        # end.if
        return true
    }

    if (json_walk_primitive() == true) return true
    if (json_walk_dict() == true) return true
    if (json_walk_array() == true) return true
    
    json_walk_panic("json_walk_value() Expect a value")
    return false
}

function json_walk_cb(s, idx0, idx1){
    print("---", idx1 substr(s, idx0, idx1 - idx0))
}

function _json_walk(    idx, nth){

    nth = -1
    while (s_idx <= s_len) {

        idx = s_idx
        
        if (json_walk_empty() == true) {     # optional
            # Do some thing in stringify()
        }

        nth ++;     JSON_WALK_KP_IDX = 1
        JSON_WALK_KP[1] = nth

        if (json_walk_value() == false) {
            # debug("json_walk_value() Out -> " s_idx " : " )
            # break
            return
        }

        print(result)
        # consume value: Do some thing in stringify()

        if (json_walk_empty() == true) {     # optional
            # Do some thing in stringify()
        }

        if (s_idx == idx) {
            json_walk_panic("json_walk() Expect a value")
        }
        
            # json_walk_cb(s, idx, s_idx)
    }
}

# global variable: text, s, s_idx, s_len
function json_walk(text_to_parsed,   b_s, b_result, b_s_idx, b_s_len, b_text){
    b_result = result;  b_text = text;
    b_s = s;    b_s_idx = s_idx;    b_s_len = s_len;

    result = "";        text = text_to_parsed;  

    if ( out_format != false ) out_compact = true

    # if (out_compact == true) {
    #     gsub(/^\357\273\277|^\377\376|^\376\377|"[^"\\\000-\037]*((\\[^u\000-\037]|\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])[^"\\\000-\037]*)*"|-?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?|null|false|true|[ \t\n\r]+|./, "\n&", text)
	#     gsub("\n" "[ \t\n\r]+", "\n", text)
    # }

    s = text;   s_idx = 1;          s_len = length(s)
    
    JSON_WALK_KP_IDX = 0

    gsub(/\\\\/, "__", s)
    gsub(/\\"/, "__", s)
    gsub(/[0123456789eE\.\+\-]/, 0, s) # number value
    
    gsub(/[\t\b\r\v]/, " ", s)

    _json_walk()

    result = b_result;  
    text = b_text;  s = b_s;    s_idx = b_s_idx;    s_len = b_s_len;
}

{
    json_walk($0)
}
